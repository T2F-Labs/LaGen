# 009: H²A²

> *Harmonic Hexagonal Actor Architecture (H²A²)*
> 
- **Status**: Accepted
- **Date**: *2025-12-07*
- **Authors**: Symphony Team

---

## 1. Summary

Symphony's Rust backend will adopt a **Hexagonal Architecture (Ports & Adapters)** combined with an **Actor model for extension isolation**. This hybrid approach provides clean domain boundaries for the core orchestration logic, a flexible adapter layer for Xi-editor integration, and robust isolation for third-party extensions through actor-based messaging.

**Core systems affected**: Backend architecture, Xi-editor integration, The Pit (infrastructure extensions), Grand Stage (user-facing extensions), and Python Conductor FFI bridge.

---

## 2. Context

### Background and Current Situation

Symphony is an AI-First Development Environment (AIDE) that aims to revolutionize software development through intelligent orchestration. The backend is being built on top of the Xi-editor foundation, a battle-tested text editing engine with rich features including rope data structures, JSON-RPC communication, and LSP support.

The critical architectural challenge is integrating Xi-editor's existing codebase with Symphony's unique requirements: a Python-based Conductor (RL orchestration model), high-performance "Pit" components requiring 50-100ns operation times, and a secure extension ecosystem ("Grand Stage") for community-developed plugins.

### Key Requirements and Constraints

1. **Performance**: The Pit components (Pool Manager, DAG Tracker, Artifact Store, Arbitration Engine, Stale Manager) must achieve 50-100ns allocation times for cache hits
2. **Isolation**: Third-party extensions must be sandboxed to prevent crashes from affecting the core system
3. **Xi-editor Integration**: Xi-editor core (rope, editing, RPC) must be preserved; the plugin system will be replaced with Symphony's extension system
4. **Testability**: Orchestration logic must be testable without starting Xi-editor or external dependencies
5. **Maintainability**: Clear boundaries to enable future modifications to Xi-editor or component replacement

### Stakeholders Affected

- **Core Development Team**: Primary implementers of the architecture
- **Extension Developers**: Community members building Instruments, Operators, and Motifs
- **AI/ML Team**: Responsible for Conductor RL model integration via PyO3
- **QA Team**: Requires isolated, mockable components for comprehensive testing
- **End Users**: Benefit from stable, performant, and extensible IDE

### Technical Environment

- **Language**: Rust (Edition 2021)
- **Runtime**: Tokio async runtime
- **FFI**: PyO3 for Python Conductor integration
- **Existing Code**: Xi-editor crates (~8 packages, migrated to `apps/backend/crates/`)
- **Frontend**: React + Tauri, communicating via JSON-RPC

---

## 3. Decision

Symphony's Rust backend will implement a **Hexagonal Architecture with Actor Hybrid**, structured as follows:

- **Domain Core**: Pure Rust modules containing orchestration logic, workflow definitions, and extension policies. Domain code depends only on port trait definitions, never on concrete adapters.
- **Ports**: Trait-based interfaces defining what the domain needs (TextEditingPort, PitPort, ExtensionPort, ConductorPort).
- **Adapters**: Concrete implementations of ports, including XiCoreAdapter (wrapping Xi-editor), PitAdapter (high-performance components), and ActorExtensionAdapter (for Grand Stage).
- **Actor Layer**: Used exclusively for Grand Stage extensions, providing process isolation and fault tolerance through message passing.

### Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           SYMPHONY BACKEND ARCHITECTURE                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                         DOMAIN CORE (Pure Rust)                        │ │
│  │                                                                        │ │
│  │   ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐      │ │
│  │   │  Orchestration  │  │    Workflow     │  │    Extension    │      │ │
│  │   │     Engine      │  │   Definitions   │  │    Policies     │      │ │
│  │   └────────┬────────┘  └────────┬────────┘  └────────┬────────┘      │ │
│  │            │                    │                    │                │ │
│  │            └────────────────────┼────────────────────┘                │ │
│  │                                 │                                     │ │
│  └─────────────────────────────────┼─────────────────────────────────────┘ │
│                                    │                                       │
│  ┌─────────────────────────────────┼─────────────────────────────────────┐ │
│  │                           PORT INTERFACES                              │ │
│  │                                 │                                      │ │
│  │   ┌─────────────┐  ┌───────────┴───────────┐  ┌─────────────┐        │ │
│  │   │TextEditing- │  │       PitPort         │  │ Extension-  │        │ │
│  │   │    Port     │  │ (Pool, DAG, Artifact) │  │    Port     │        │ │
│  │   └──────┬──────┘  └───────────┬───────────┘  └──────┬──────┘        │ │
│  │          │                     │                     │                │ │
│  └──────────┼─────────────────────┼─────────────────────┼────────────────┘ │
│             │                     │                     │                  │
│  ┌──────────┼─────────────────────┼─────────────────────┼────────────────┐ │
│  │          │              ADAPTER LAYER                │                 │ │
│  │          │                     │                     │                 │ │
│  │   ┌──────┴──────┐  ┌───────────┴───────────┐  ┌──────┴──────┐        │ │
│  │   │  Xi-Core    │  │     Pit Adapter       │  │Actor-Based  │        │ │
│  │   │  Adapter    │  │  (Direct Rust calls)  │  │  Extension  │        │ │
│  │   │             │  │                       │  │   Adapter   │        │ │
│  │   └──────┬──────┘  └───────────┬───────────┘  └──────┬──────┘        │ │
│  │          │                     │                     │                │ │
│  └──────────┼─────────────────────┼─────────────────────┼────────────────┘ │
│             │                     │                     │                  │
│  ┌──────────┴──────┐  ┌───────────┴───────────┐  ┌──────┴──────────────┐  │
│  │    XI-EDITOR    │  │       THE PIT         │  │    GRAND STAGE      │  │
│  │   (xi-rope,     │  │  ┌─────────────────┐  │  │   (Actor System)    │  │
│  │  xi-core-lib,   │  │  │  Pool Manager   │  │  │                     │  │
│  │    xi-rpc)      │  │  │  DAG Tracker    │  │  │  ┌──────────────┐   │  │
│  │                 │  │  │  Artifact Store │  │  │  │ Instruments  │   │  │
│  │  ❌ xi-plugin   │  │  │  Arbitration    │  │  │  │  Operators   │   │  │
│  │  (NOT USED)     │  │  │  Stale Manager  │  │  │  │   Motifs     │   │  │
│  │                 │  │  └─────────────────┘  │  │  └──────────────┘   │  │
│  └─────────────────┘  └───────────────────────┘  └─────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

```

---

## 4. Rationale

### 4.1 Clean Separation Between Xi-Editor and Symphony Logic

The Hexagonal pattern places Xi-editor behind a `TextEditingPort` interface, ensuring Symphony's orchestration logic never directly depends on Xi-editor's internal APIs. This provides insulation against Xi-editor API changes, enables unit testing without starting Xi-editor, and allows potential future replacement or significant modification of the text editing layer.

**Quantitative Impact**: Reduces coupling from ~50 direct Xi-editor imports across the codebase to a single adapter file of approximately 500-800 LOC.

### 4.2 Performance-Optimized Pit Through Direct Calls

The Pit components operate through a `PitPort` interface but are implemented as direct Rust struct calls within the adapter, avoiding actor message-passing overhead. This achieves the required 50-100ns allocation times for hot paths while maintaining a clean interface for testing.

**Performance Comparison**:

- Actor message passing: 100ns - 1μs per message
- Direct function call through trait: ~10-50ns
- Target achieved: ✅ Meets 50-100ns requirement

### 4.3 Fault-Isolated Extension System via Actors

Third-party extensions (Instruments, Operators, Motifs) run through the Actor layer, providing automatic fault isolation. If an extension panics, it cannot crash the core system. This aligns with Symphony's security requirements for a community extension marketplace.

**Business Impact**: Enables safe marketplace distribution of third-party extensions, a key differentiator for Symphony's ecosystem growth.

### 4.4 Testability Through Port Abstraction

All ports can be mocked using standard Rust tooling (mockall), enabling comprehensive unit testing of orchestration logic without external dependencies. This reduces CI/CD pipeline times and improves developer productivity.

**Quantitative Impact**: Expected 60-70% reduction in test execution time for unit tests; eliminates need for Xi-editor process startup in most tests.

### 4.5 Xi-Editor Plugin System Replacement

By routing all extension functionality through Symphony's `ExtensionPort` and adapter, the legacy Xi-editor plugin system (`xi-plugin-lib`) is completely bypassed. This enables Symphony to implement its own extension manifest format, sandboxing model, and marketplace integration without legacy constraints.

**Strategic Alignment**: Supports Symphony's goal of a unified extension ecosystem (Orchestra Kit) independent of Xi-editor's design decisions.

### 4.6 Incremental Migration Path

The architecture allows incremental adoption: Xi-editor integration can be completed first, then Pit components, then the extension system. Each layer is independently testable and deployable.

**Timeline Impact**: Reduces risk of "big bang" integration; enables parallel development across teams.

### Trade-offs Accepted

| Trade-off | Why Acceptable | Mitigation |
| --- | --- | --- |
| **Two mental models** (Hexagonal + Actors) | Actors only used for extensions; core team uses Hexagonal | Clear documentation; actors contained to one subsystem |
| **Port interface design effort** | Required upfront but pays off in flexibility | Design ports based on domain needs, not Xi-editor API |
| **Adapter boilerplate** | ~500-800 LOC per major adapter | Auto-generate trivial adapters; focus manual effort on complex ones |
| **Trait vtable overhead** (~1-2ns) | Negligible compared to actual operation costs | No mitigation needed; overhead is unmeasurable in practice |

---

## 5. Alternatives Considered

### Alternative A: Pure Actor-Service Model

**Description**: All components (Xi-editor, Pit, Extensions) operate as actors communicating via message passing.

**Pros**:

- Single consistent paradigm across entire codebase
- Natural fault isolation for all components
- Proven pattern with mature Rust libraries (Actix, Tokio actors)
- Location-transparent; same code works in-process or distributed

**Cons**:

- Actor message overhead (100ns-1μs) conflicts with Pit's 50-100ns requirement
- Requires internal bypass mechanism for Pit hot paths, creating hidden complexity
- Testing actors requires async test harnesses; more complex than trait mocking
- Xi-editor integration becomes awkward (wrapping RPC-based system in another messaging layer)

**Rejected because**: The Pit performance requirements cannot be met with pure actor messaging without introducing bypass mechanisms that undermine the architectural consistency. Additionally, the double-messaging (Xi-editor's JSON-RPC + Actor messages) adds unnecessary complexity.

### Alternative B: Event Sourcing + Actor Model

**Description**: Add event sourcing to capture all state changes for replay and auditing, on top of actor-based architecture.

**Pros**:

- Complete audit trail for all system state changes
- Time-travel debugging for complex issues
- Perfect replay capability for Conductor RL training
- Natural fit for CQRS if read/write separation needed

**Cons**:

- Highest learning curve (~3 months to proficiency)
- Event schema evolution is challenging; breaking changes are difficult
- Storage growth requires snapshot strategies
- Conceptual mismatch with Xi-editor's CRDT-based undo (two conflict resolution models)
- Rust event sourcing ecosystem less mature than Java/Scala alternatives

**Rejected because**: The complexity overhead is not justified for the current project phase. Event sourcing can be added selectively later (for Conductor decisions and Artifact Store) without requiring it for the entire system. The RL training benefit can be achieved through targeted instrumentation rather than full event sourcing.

### Alternative C: Layered Architecture (Traditional N-Tier)

**Description**: Simple layered approach with Presentation → Application → Domain → Infrastructure layers.

**Pros**:

- Most familiar pattern to developers; shortest learning curve
- Minimal abstraction overhead
- Straightforward to implement and debug
- No specialized patterns to learn

**Cons**:

- Dependencies flow in one direction; infrastructure changes ripple upward
- No clear boundary for Xi-editor integration; coupling risk
- Extension system would require ad-hoc isolation mechanism
- Testing requires full dependency chain or extensive mocking

**Rejected because**: The lack of explicit port boundaries makes Xi-editor integration brittle. As Symphony evolves, the tight coupling between layers would make refactoring increasingly difficult. The architecture doesn't naturally support the dual requirement of high-performance internal components and isolated external extensions.

---

## 6. Consequences

### Positive Consequences

1. **Maintainability**: Clear boundaries between domain logic and infrastructure enable changes to either without affecting the other. Xi-editor can be upgraded, modified, or even replaced without orchestration logic changes.
2. **Testability**: Domain logic can be fully unit-tested with mocked ports, reducing test infrastructure needs and accelerating CI/CD. Expected 60-70% faster unit test suites compared to integration-only testing.
3. **Performance**: The Pit achieves required 50-100ns operation times through direct Rust calls, while extensions remain safely isolated through the actor layer.
4. **Extension Ecosystem**: The architecture naturally supports Symphony's Orchestra Kit vision with secure, isolated extensions that cannot destabilize the core system.

### Negative Consequences

1. **Initial Design Overhead**: Port interfaces must be carefully designed upfront. Poor port design leads to awkward adapters or frequent interface changes. Estimated 2-3 weeks of design effort before implementation.
2. **Two Paradigms**: Developers must understand both Hexagonal (ports/adapters) and Actor (for extensions) patterns. This increases onboarding time by approximately 1-2 weeks for new team members.
3. **Adapter Maintenance**: Each external integration requires an adapter implementation. As Symphony integrates more external tools, adapter count grows proportionally.
4. **Indirection Complexity**: Debugging requires understanding port→adapter→implementation flow. Stack traces span multiple abstraction layers, which can slow initial troubleshooting.

---

## 7. Success Criteria

| Criterion | Target | Measurement Method |
| --- | --- | --- |
| **Pit Performance** | 50-100ns for Pool Manager allocation (cache hit) | Benchmark suite with [criterion.rs](http://criterion.rs/) |
| **Test Coverage** | 80%+ code coverage for domain core without integration tests | cargo-tarpaulin coverage reports |
| **Extension Isolation** | Extension panic does not crash core system | Chaos testing with intentional panics |
| **Build Independence** | Xi-editor crates can be updated without domain recompilation | CI verification of crate dependency tree |
| **Developer Productivity** | Unit tests complete in <30s, full suite in <5min | CI pipeline metrics |
| **Onboarding Time** | New developers productive within 2 weeks | Team feedback surveys |

---

## 8. Risks and Mitigations

| Risk | Impact | Mitigation |
| --- | --- | --- |
| **Port interface instability** | High - Frequent changes ripple to all adapters | Invest 2-3 weeks in upfront design; conduct domain modeling workshops |
| **Actor framework lock-in** | Medium - Switching Actix/Tokio actors requires adapter rewrite | Contain actor usage to extension adapter; abstract via trait if needed |
| **Xi-editor deep modification needs** | Medium - Some features may require Xi-editor internals | Design adapter to allow selective internal access; maintain xi-core-reference for documentation |
| **Performance regression** | High - Trait indirection accumulates | Establish benchmark suite early; CI fails on performance regression |
| **Team skill gap** | Medium - Hexagonal pattern unfamiliar | Conduct architecture workshops; create coding guidelines document |
| **Over-engineering ports** | Low - Too many fine-grained ports | Follow "change together = same port" rule; periodic design review |

---

## References

- [Hexagonal Architecture (Alistair Cockburn)](https://alistair.cockburn.us/hexagonal-architecture/)
- [Actor Model in Rust (Actix Documentation)](https://actix.rs/)
- [Xi-Editor Architecture](https://github.com/xi-editor/xi-editor)
- [Symphony Methodology Documentation](https://www.notion.so/docs/methodology/)
- [The Kernels - Conductor Behavioral Model](https://www.notion.so/docs/methodology/The%20Kernels.md)

---

## Appendix: Initial Port Definitions

```rust
// Core editing operations
pub trait TextEditingPort: Send + Sync {
    fn insert(&self, buffer_id: BufferId, pos: usize, text: &str) -> Result<Revision>;
    fn delete(&self, buffer_id: BufferId, range: Range<usize>) -> Result<Revision>;
    fn get_content(&self, buffer_id: BufferId) -> Result<RopeSlice>;
    fn undo(&self, buffer_id: BufferId) -> Result<Revision>;
    fn redo(&self, buffer_id: BufferId) -> Result<Revision>;
    fn subscribe(&self, buffer_id: BufferId) -> Receiver<BufferEvent>;
}

// High-performance Pit operations
pub trait PitPort: Send + Sync {
    fn allocate_model(&self, spec: ModelSpec) -> Result<ModelHandle>;
    fn release_model(&self, handle: ModelHandle) -> Result<()>;
    fn execute_dag_node(&self, node: DagNode) -> Result<NodeResult>;
    fn store_artifact(&self, content: ArtifactContent) -> Result<ArtifactId>;
    fn resolve_conflict(&self, conflict: Conflict) -> Result<Resolution>;
}

// Extension lifecycle and communication
pub trait ExtensionPort: Send + Sync {
    async fn load(&self, manifest: ExtensionManifest) -> Result<ExtensionId>;
    async fn unload(&self, id: ExtensionId) -> Result<()>;
    async fn invoke(&self, id: ExtensionId, request: Request) -> Result<Response>;
    fn events(&self, id: ExtensionId) -> Receiver<ExtensionEvent>;
}

// Python Conductor bridge
pub trait ConductorPort: Send + Sync {
    fn submit_decision(&self, context: DecisionContext) -> Result<Decision>;
    fn report_reward(&self, episode: EpisodeId, reward: f64) -> Result<()>;
    fn get_policy(&self, context: &PolicyContext) -> Result<Policy>;
}

```

---

## Reference:

[Feasibility](Feasibility%202c2461aa27058060953ef6c1837bbb7c.md)

[Options Analysis](Options%20Analysis%202c2461aa27058052bfe5e5a008530403.md)

---