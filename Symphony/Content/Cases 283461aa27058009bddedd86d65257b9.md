# Cases

# TL;DR (one-sentence)

- **Static (fully embedded)** = simplest, fastest, safest for bootstrap and trusted, low-change code — **requires rebuild to change**.
- **In-process dynamic (.so/.dll) plugins** = good compromise: fast and replaceable, but *hard* to get ABI, safety, unloading and allocators correct.
- **Out-of-process IPC plugins** = slowest per-call but best for isolation, independent deploys, language/runtime freedom and safety.

---

# Quick comparison table (high level)

| Dimension | Static (embed) | In-process dynamic libs | Out-of-process (IPC) |
| --- | --- | --- | --- |
| Bootstrapping simplicity | ✅ easiest | ⚠️ moderate (loader needed) | ⚠️ moderate (IPC server + discovery) |
| Runtime performance | ✅ best (direct calls) | ✅ nearly as good (native calls) | ❌ higher latency (serialization + IPC) |
| Crash isolation | ❌ none | ❌ none (same process) | ✅ strong (process boundaries) |
| Hot-reload / dev iteration | ❌ rebuild required | ✅ possible (drop-in .so) | ✅ easiest (restart process) |
| ABI complexity | ✅ trivial | ⚠️ hard (ABI stability required) | ✅ simple (wire protocol) |
| Security / sandboxing | ❌ none | ⚠️ limited | ✅ can sandbox (containers, seccomp, namespaces) |
| Packaging/deploy complexity | ✅ single artifact | ⚠️ multi-artifact (shared libs) | ⚠️ multi-artifact + orchestration |
| Observability & metrics | ⚠️ straightforward | ⚠️ straightforward | ✅ best (separate telemetry per process) |
| Dev & CI cost | ✅ low | ⚠️ medium | ⚠️ higher |
| Use-case fit | Trusted core, perf-critical | Trusted, frequently updated perf modules | Third-party / unsafe / independent services |

---

# Deep dive by axis

## 1) Boot & deployment behavior

- **Static**: Python loads one extension (PyO3 `cdylib`) — everything is initialized by Rust on import. Simple installer (one wheel / package). Good for CI reproducibility.
- **In-process dynamic**: Python loads a core Rust host library that *dynamically loads* other `.so`/`.dll` files (via `libloading`). Host must keep `Library` handles alive to avoid unloading. On Windows, file locking complicates replacement. You must implement discovery, version compatibility checks, and safe init/uninit.
- **Out-of-process**: Python loads only the IPC client module; the IPC server (Rust) spawns or connects to external extension processes. Extensions register over defined protocol. Deploy each extension separately (binaries, containers, services).

## 2) Performance & latency

- **Static**: Direct function/trait calls — lowest overhead (sub-microsecond for small function calls on native code).
- **In-process dynamic**: Native calls too, but with an extra indirection (function pointer, possibly `extern "C"` trampoline). Overhead negligible in most cases; still best for microsecond-level work.
- **Out-of-process**: Serialization (JSON/CBOR/protobuf), socket/pipe context switches, scheduling — typical latencies go from hundreds of microseconds to multiple milliseconds depending on transport (AF_UNIX faster than TCP) and payload size. Not ideal for sub-microsecond critical paths.

## 3) Crash isolation, stability, and security

- **Static & In-process dynamic**: A plugin crash (panic, segfault) kills the whole process — unacceptable for untrusted or brittle code. Also a buggy plugin can corrupt host memory.
- **Out-of-process**: Crash contained in plugin process. Host can restart plugin, rate-limit, sandbox, and enforce resources (cgroups). Best choice when stability/availability are priorities.

## 4) ABI, safety, and Rust specifics

- Rust has **no stable Rust ABI** across crates/dylibs. That breaks naive trait/object sharing across `.so` boundaries.
    - **Danger**: passing Rust trait objects or Rust-owned structs across a dylib boundary is undefined behavior unless you use a stability layer.
- **Solutions**:
    - Use `extern "C"` entry points and opaque pointers + C-style vtables. Must carefully provide matching allocation/deallocation functions and panic-safety wrappers.
    - Use `abi_stable` crate (or similar) to create a stable ABI for plugin interfaces (recommended if you want in-process dynamic plugins).
    - Or avoid cross-dylib ABI by: 1) keeping everything statically linked, or 2) moving plugin boundary to *IPC* (JSON/RPC, gRPC, cap’n proto), which completely sidesteps ABI problems.
- **PyO3 caveat**: loading multiple PyO3 modules or performing certain dynamic module tricks can cause module-name collisions or initialization complexity. Prefer a **single PyO3 host module** that manages plugin loading via Rust `libloading`, not multiple PyO3 extension modules.

## 5) Memory management, allocators, and unloading

- When using dynamic libs:
    - If the plugin allocates memory and host frees it (or vice versa), ensure both use the same allocator or provide explicit free functions exported by the plugin.
    - Unloading libraries (`dlclose`) while threads are executing code in them is UB. Usually safest policy: **never unload**—only load once and keep the handle for the process lifetime — or restart the process to reload.
- Static linking avoids these issues entirely.

## 6) Concurrency & runtimes (tokio / threads / Python GIL)

- If Rust side runs async work (tokio), decide **who owns the runtime**:
    - Single runtime inside host is preferable. Plugins should not create new global runtimes.
    - If plugins run in separate processes, they can own their own runtimes safely.
- Interaction with Python:
    - PyO3 calls can release the Python GIL for long-running Rust work (`Python::allow_threads`).
    - If Rust callbacks into Python, they must acquire the GIL — coordinate to avoid deadlocks.
- Be careful about threads that start inside a plugin: if plugin code spawns background threads and then plugin is unloaded, those threads may try to call freed code.

## 7) Debugging, observability, and testing

- **Static**: easiest to debug within single process; stack traces show combined symbols; single test/integration run includes everything.
- **In-process dynamic**: debugging native code similar to static, but symbol loading / source mapping for dynamically loaded libs is extra step. Unit-test plugins independently.
- **Out-of-process**: easiest to attach debuggers to plugin processes independently, collect per-service metrics/logs, and do independent CI pipelines.

## 8) Packaging & CI

- **Static**: build one release artifact (Python wheel that contains compiled `symphony_ipc`), simpler CI and releases.
- **In-process dynamic**: CI must build host + plugin shared libs; version compatibility checks; package either as one installer or multiple packages. On Windows, expect locking issues for in-place replace.
- **Out-of-process**: independent CI per extension, container images per extension — more flexible but more moving parts.

## 9) Hot-reload, state migration & upgrades

- **Static**: no hot reload. Upgrade = deploy new binary. Simple state migration strategies or in-process state serialization required.
- **In-process dynamic**: you *can* replace plugin `.so` and re-register, but it's hard:
    - Need to quiesce plugin, serialize/transfer state to new code, ensure no threads reference old code, then swap handle — tricky and error prone.
- **Out-of-process**: easier hot swap — spin up new process, pipe/transfer state (via snapshot, DB, or transfer protocol), then cut traffic over. Much cleaner for migration.

## 10) Security & sandboxing

- **Static/In-process dynamic**: plugin runs with full host privileges. Use code review and trust model. You can add process-level mitigations (SECCOMP, ulimits) but they're limited inside same process.
- **Out-of-process**: sandbox per plugin (containers, seccomp, user namespaces, chroot). Best for running third-party or user-submitted code.

---

# Concrete technical patterns & gotchas

### If you want in-process dynamic plugins — safe pattern checklist

1. **Use `cdylib` + `extern "C"` factory functions** or `abi_stable`. Do not pass Rust trait objects across boundaries without ABI layer.
2. **Export a C-style vtable** from plugin or a factory `extern "C" fn create_plugin() -> *mut c_void` plus `extern "C" fn plugin_vtable() -> *const PluginVTable`.
3. **Provide allocation/deallocation functions** across the plugin boundary (`plugin_alloc`, `plugin_free`) if the plugin returns heap memory.
4. **Wrap all FFI calls with `catch_unwind`** to prevent Rust panics crossing FFI boundary.
5. **Keep `Library` handle alive** (store it in the host) to avoid implicit `dlclose`.
6. **Do not unload** unless you can guarantee zero threads executing plugin code and all state safely migrated.
7. **Use `abi_stable` if you want ergonomics** — it implements patterns for trait objects and vtables with stable ABI.
8. **Test on each target OS** — Windows DLL semantics differ (files locked while loaded).
9. **Design versioning & compatibility**: plugin and host must negotiate API versions at load time.

### Minimal C-style plugin API (illustrative)

```c
// plugin exports (C ABI)
extern "C" {
  // returns an opaque handle
  void* plugin_create();
  // calls and returns heap-allocated C string (caller frees with plugin_free_string)
  char* plugin_handle_message(void* plugin, const char* json);
  void plugin_destroy(void* plugin);
  void plugin_free_string(char* s);
  int  plugin_api_version(); // compatibility
}

```

Host loads those functions via `libloading` and uses them — avoids Rust ABI pitfalls.

### Pitfall: multiple PyO3 modules / Python extension name collisions

- Don’t build each plugin as a PyO3 Python module that you `import` — that gets messy. Instead:
    - Build one PyO3 host extension (`symphony_ipc`) used by Python.
    - That host calls into plugin `.so` files at the native layer (no Python-level imports per plugin).

---

# Alternatives worth considering

- **WASM (WASI)**: Run plugins as WebAssembly modules inside the host (wasmtime/wasmer). Good sandboxing and portability; lower ability to use native CPU instructions directly; still gaining ecosystem for syscalls and host bindings.
- **Sandboxed in-process with strong typing**: Use `plugin` model + `WASI` or `nativecapnp` + memory-mapped shared buffers for fast IPC.
- **gRPC / capnp / flatbuffers** over local sockets for faster structured RPC with schema.

---

# Practical recommendations for *Symphony* (actionable plan)

1. **Bootstrap quickly: start static.**
    - Build `symphony_ipc` as one PyO3 `cdylib` that statically includes the first version of Pit extensions (PoolManager, DagTracker).
    - This resolves the chicken-egg problem simply and is safest for early iterations.
2. **Design a stable extension contract from day 0.**
    - Define a small, stable, versioned **extension interface**: registration, `handle_message(json)`, lifecycle hooks, API version.
    - Make the contract serializable (JSON) so future migration to IPC is trivial.
3. **Instrument for later split: keep state isolated & serializable.**
    - Ensure every Pit extension keeps its state in a serializable object and exposes snapshot/restore API. That makes hot-swap and out-of-process migration feasible.
4. **Prepare for 2nd phase (in-process dynamic or IPC):**
    - If you want replaceability with low-latency calls, implement an **ABI-stable loader** (use `abi_stable` or C ABI shim) and move selected Pit modules to `.so` files.
    - If safety and independent deployment are top priorities, move them out-of-process and use a fast local IPC protocol (AF_UNIX + MessagePack/protobuf).
5. **Mapping by trust/performance:**
    - **Trusted, super-low-latency** core services: keep static or move to ABI-stable in-process plugins.
    - **Frequently updated but trusted** services: in-process dynamic with `abi_stable` if you need low latency.
    - **Untrusted / third-party / crash-risky** services: out-of-process IPC with sandboxing.
6. **If you need true hot-reload and developer iteration speed quickly:**
    - Implement out-of-process plugin mode for dev: run plugin processes locally and allow Conductor to spawn/reload them easily. This gives the fastest dev iteration with minimal runtime risk.

---

# Example migration roadmap (practical)

1. **M0 (now)**: Static linking inside `symphony_ipc`. Single PyO3 module. Fast to build/test.
2. **M1**: Add plugin registration API and snapshot/restore state methods to all Pit modules. Implement versioned contract.
3. **M2a**: If you prioritize performance, convert one Pit module to an ABI-stable `.so` plugin using `abi_stable` and test loader with host. Keep all other pits static.
    
    **M2b**: Alternatively (or concurrently), implement out-of-process mode for the same module and benchmark. Choose winner based on perf vs safety.
    
4. **M3**: Provide packaging for independent plugins (wheels, debs, or containers), CI that builds host and plugins separately, and runtime checks for compatibility.
5. **M4**: If many third-party plugins expected, finalize an IPC protocol and governance for sandboxing and resource limits.

---

# Final checklist before you pick one

- Do you need **sub-microsecond** responses? → static or in-process dynamic.
- Will plugins be **untrusted**? → out-of-process with sandbox.
- Do you need **frequent binary changes** without core rebuilds? → out-of-process or carefully designed in-process ABI plugins.
- Can you accept **engineering complexity** now? → static for now, evolve later.
- Is **process crash tolerance** required? → out-of-process.

---

## My pragmatic recommendation for Symphony

- **Short term / bootstrap:** Start **static** (single PyO3 `symphony_ipc` that inits Pit). Easiest, least surprising, and resolves chicken–egg.
- **Medium term:** Design and stabilize the extension contract and state snapshot API.
- **Long term:** Move high-risk/frequently-updated code to **out-of-process**. For a small set of trusted, latency-critical services, consider **ABI-stable in-process plugins** (use `abi_stable` or C ABI and strict safety wrappers).

---